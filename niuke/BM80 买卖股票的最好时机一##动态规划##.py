描述
假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益
1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天
2.如果不能获取到任何利润，请返回0
3.假设买入卖出均无手续费

解题思路：
买卖股票有约束，根据题目意思，有以下两个约束条件：
    条件 1：你不能在买入股票前卖出股票；
    条件 2：最多只允许完成一笔交易。
因此 当天是否持股 是一个很重要的因素，而当前是否持股和昨天是否持股有关系，为此我们需要把 是否持股 设计到状态数组中
状态定义：
dp[i][j]：下标为 i 这一天结束的时候，手上持股状态为 j 时，我们持有的现金数。
    j = 0，表示当前不持股；
    j = 1，表示当前持股。
注意：这个状态具有前缀性质，下标为 i 的这一天的计算结果包含了区间 [0, i] 所有的信息，因此最后输出 dp[len - 1][0]
推导状态转移方程：
dp[i][0]：规定了今天不持股，有以下两种情况：
    昨天不持股，今天什么都不做；
    昨天持股，今天卖出股票（现金数增加），
    状态转移方程：dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
dp[i][1]：规定了今天持股，有以下两种情况：
    昨天持股，今天什么都不做（现金数与昨天一样）；
    昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）
    状态转移方程：dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);

 class Solution:
    def maxProfit(self , prices: List[int]) -> int:
        # write code here
        if len(prices) < 2: return 0

        // dp[i][0] 下标为 i 这天结束的时候，不持股，手上拥有的现金数
        // dp[i][1] 下标为 i 这天结束的时候，持股，手上拥有的现金数
        // 初始化：不持股显然为 0，持股就需要减去第 1 天（下标为 0）的股价
        dp = [[0, 0] for _ in  range(len(prices))]
        dp[0][0] = 0
        dp[0][1] = -prices[0]
        for i in range(1, len(prices)):
            dp[i][0]=max(dp[i-1][0], dp[i-1][1]+prices[i])
            dp[i][1]=max(dp[i-1][1], -prices[i])
        return dp[len(prices)-1][0]