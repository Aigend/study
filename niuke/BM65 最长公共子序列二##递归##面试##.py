描述
给定两个字符串str1和str2，输出两个字符串的最长公共子序列。
如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

输入：
"1A2C3D4B56","B1D23A456A"
返回值：
"123456"
思路：

题目要求获取最长公共子序列，我们肯定要先知道最长到底是多长，
因此肯定要先求最长公共子序列的长度，然后根据这个长度获取这个子序列。
（注意：子序列不是子串，子串要求所有字符必须连续，子序列不要求连续，只要求相对位置不变）
具体做法：

step 1：优先检查特殊情况。
step 2：获取最长公共子序列的长度可以使用动态规划，我们以
		dp[i][j]表示在s1中以i结尾，s2中以j结尾的字符串的最长公共子序列长度。

step 3：遍历两个字符串的所有位置，开始状态转移：若是i位与j位的字符相等，则该问题可以变成
		1+dp[i−1][j−1]，即到此处为止最长公共子序列长度由前面的结果加1。

step 4：若是不相等，说明到此处为止的子串，最后一位不可能同时属于最长公共子序列，毕竟它们都不相同，
		因此我们考虑换成两个子问题，dp[i][j−1]或者dp[i−1][j]，我们取较大的一个就可以了，由此感觉可以用递归解决。
step 5：但是递归的复杂度过高，重复计算了很多低层次的部分，
		因此可以用动态规划，从前往后加，由此形成一个表，表从位置1开始往后相加，正好符合动态规划的转移特征。
step 6：因为最后要返回该序列，而不是长度，所以在构造表的同时要以另一个二维矩阵记录上面状态转移时选择的方向，
		我们用1表示来自左上方，2表示来自左边，3表示来自上边。
step 7：获取这个序列的时候，根据从最后一位开始，根据记录的方向，
		不断递归往前组装字符，只有来自左上的时候才添加本级字符，
		因为这种情况是动态规划中两个字符相等的情况，字符相等才可用。

import sys
#设置递归深度
sys.setrecursionlimit(100000) 
class Solution:
    def __init__(self):
        self.x = ""
        self.y = ""
        
    #获取最长公共子序列
    def ans(self, i: int, j: int, b: List[List[int]]): 
        res = ""
        #递归终止条件
        if i == 0 or j == 0: 
            return res
        #根据方向，往前递归，然后添加本级字符
        if b[i][j] == 1:
            res = res + self.ans(i - 1, j - 1, b)
            res = res + self.x[i - 1]
        elif b[i][j] == 2:
            res = res + self.ans(i - 1, j, b)
        elif b[i][j] == 3:
            res = res + self.ans(i, j - 1, b)
        return res

    def LCS(self , s1: str, s2: str) -> str:
        #特殊情况
        if s1 is None or s2 is None: 
            return "-1"
        len1 = len(s1)
        len2 = len(s2)
        self.x = s1
        self.y = s2
        #dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度
        dp = [[0] * (len2 + 1) for i in range(len1 + 1)]
        #动态规划数组相加的方向
        b = [[0] * (len2 + 1) for i in range(len1 + 1)]
        #遍历两个字符串每个位置求的最长长度
        for i in range(1, len1 + 1): 
            for j in range(1, len2 + 1):
                #遇到两个字符相等
                if s1[i - 1] == s2[j - 1]:
                    #考虑由二者都向前一位
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    #来自于左上方
                    b[i][j] = 1 
                #遇到的两个字符不同
                #左边的选择更大，即第一个字符串后退一位
                elif dp[i - 1][j] > dp[i][j - 1]:
                    dp[i][j] = dp[i - 1][j]
                    #来自于左方
                    b[i][j] = 2 
                #右边的选择更大，即第二个字符串后退一位
                else:
                    dp[i][j] = dp[i][j - 1]
                    #来自于上方
                    b[i][j] = 3 
        #获取答案字符串
        res = self.ans(len1, len2, b)
        #检查答案是否位空
        if res is None or res == "":
            return "-1"
        else:
            return res